---
format:
  html:
    code-fold: false
    echo: false
    output: false
    toc-expand: 2
    toc-title: 目录
    # fig-xxx 仅影响 matplotlib 绘图，不影响 pyecharts
    fig-align: center
    #fig-format: svg
    #fig-dpi: 400 # svg 时无效

---

```{python}
from datetime import datetime as dt
import math

import numpy as np
import pandas as pd

from pyecharts import types
from pyecharts import options as opts
from pyecharts.charts import Line, Grid, Bar, Sunburst
from pyecharts.components import Table
from pyecharts.commons.utils import JsCode
```

```{python}
###### 全局变量 ######
# 已经出了成绩的最新年份
scoredyear = "2025"
years = [f"{y}" for y in list(range(2019, int(scoredyear) + 1, 1))]
years_score = [f"[{y}]" for y in years]
print(f"已出分年度: {years}")
print(f"data 中已出分年度的 column 名称: {years_score}")
# 报名人数（假设数据）
enroll_number_2023 = 126000  # 2023 年报名人数
ac_rate_2023 = 0.45  # 2023 年 AC 类报名比例
enroll_number_2023_ac = (
    math.ceil(enroll_number_2023 * ac_rate_2023 / 100) * 100
)  # 2023 年 AC 类报名人数
enroll_number_2023_d = enroll_number_2023 - enroll_number_2023_ac
enroll_number_2024 = 132400  # 2024 年报名人数
ac_rate_2024 = 0.47  # 2023 年 AC 类报名比例
enroll_number_2024_ac = (
    math.ceil(enroll_number_2024 * ac_rate_2024 / 100) * 100
)  # 2024 年 AC 类报名人数
enroll_number_2024_d = enroll_number_2024 - enroll_number_2024_ac
```

```{python}
# 全局变量
g_toolbox_opts=opts.ToolboxOpts(
    feature=opts.ToolBoxFeatureOpts(
        save_as_image = opts.ToolBoxFeatureSaveAsImageOpts(
            background_color="white",
            pixel_ratio = 5), 
        restore=None,
        data_view=None,
        data_zoom=None,
        magic_type=None,
        # brush = opts.BrushOpts(),
    )
),

def get_title(titlestr: str = ""):
    return opts.TitleOpts(
        title=titlestr,
        title_link="https://wkevin.github.io/szzk",
        subtitle=f"https://wkevin.github.io/szzk\n{dt.now().strftime('%Y-%m-%d')}",
        subtitle_link="https://wkevin.github.io/szzk",
        subtitle_textstyle_opts=opts.TextStyleOpts(font_size=12),
    )
```

```{python}
# 加载数据
# read_csv(dtype, engine)
#   pandas 首先尝试某列是否可数值化（numeric）
#   不可数值化：视为 str
#   可以数值化 & dtype 没有指定为 'str': 按 int、float 顺序尝试解析
#       遇到列中有 NaN（pandas 中的一种特殊 float 值）, 此列按 float 解析；
#       遇到列中没有 NaN，则按 int、float 顺序尝试解析；
#       所以 scoredyear 最新年份的录取分中没有 Nan，导致解析为 int，与其他的 float 不一致，此处统一为 float
#   engine: 默认为 'c', 还可以 'python'
df_score_ac = pd.read_csv(
    f"./dataset/admit_score_ac.csv", decimal=",", dtype={f"[{scoredyear}]": float}
)

df_admit_number_2023 = pd.read_csv(
    f"./dataset/admit_number_2023.csv", decimal=","
).rename(columns={"招生人数": "招生人数_2023", "指标生": "指标生人数_2023"})

df_admit_number_2024 = pd.read_csv(
    f"./dataset/admit_number_2024.csv", decimal=","
).rename(columns={"招生人数": "招生人数_2024", "指标生": "指标生人数_2024"})

# 使用最新年份的学校信息，根据代码合并 df
# 不再招生的学校就不显示了
df = df_admit_number_2024.merge(
    df_admit_number_2023.drop("学校名称", axis=1).drop("办学性质", axis=1),
    on="代码",
    how="left",
).merge(df_score_ac, on="代码", how="left")


# 添加新列 type：表示 AC、D 类
def assign_type(name: str):
    if "（一）" in name:
        return "AC"
    elif "（二）" in name:
        return "D"
    else:
        return "ACD"


df["type"] = df["学校名称"].apply(assign_type)
# df.to_csv("foobar.csv")

# 添加每年的排序
# 第一序：分数（[year]）
# 第二序：招生人数（招生人数_year）-- 招生人数多着靠前
# 第三序：代码 -- 代码小的靠前
l = len(df)
for y in years:
    _l = len(df[df[f"[{y}]"].notnull()])
    if f"招生人数_{y}" in df.columns.tolist():
        df = df.sort_values(
            by=[f"[{y}]", f"招生人数_{y}", "代码"], ascending=[False, False, True]
        )
    else:
        df = df.sort_values(by=[f"[{y}]", "代码"], ascending=[False, True])

    zs = np.zeros(l)
    zs[:] = np.nan

    for i in range(0, _l, 1):
        zs[i] = i + 1
    df.insert(len(df.columns), y, zs)
(df) 
```

```{python}
def transpose_ac_and_d(year: str, only_gov=True, add_new_tag=True, df_input=None):
    """将 df_input 中的 AC 和 D 类的招生人数从行转置到列），重新命名为新列：
    AC、D、ACD、AC_指标生、D_指标生、ACD_指标生；
    将学校名称中的（一）、（二）去掉；
    按指定 year 排序，如果 scoredyear 还没有到 year 年度，则按 scoredyear 排序；
    并可识别指定年份是否为新校，添加 new 标签
    """

    _df = df.copy() if df_input is None else df_input

    if only_gov:
        _df = _df[_df["办学性质"] == "公办"]  # 去掉民办

    ### AC、D、ACD 类人数合并一行，代码使用 AC 的
    _df_0 = _df[~_df["学校名称"].str.contains("（二）")]  # 筛出 AC & ACD
    _df_0.loc[:, "学校名称"] = _df_0["学校名称"].str.replace(
        "（一）", ""
    )  # 列名中去掉 (一)

    _df_1 = _df[_df["学校名称"].str.contains("（一）")]  # 筛出 AC 类
    _df_1 = _df_1.rename(columns={f"招生人数_{year}": "AC"})  # 列名改为AC
    _df_1 = _df_1.rename(columns={f"指标生人数_{year}": "AC_指标生"})  # 列名改为AC
    _df_1 = _df_1[["代码", "AC", "AC_指标生"]]

    _df_2 = _df[_df["学校名称"].str.contains("（二）")]  # 筛出 D 类
    _df_2.loc[:, "学校名称"] = _df_2["学校名称"].str.replace("（二）", "")
    _df_2 = _df_2.rename(columns={f"招生人数_{year}": "D"})
    _df_2 = _df_2.rename(columns={f"指标生人数_{year}": "D_指标生"})
    _df_2 = _df_2[["学校名称", "D", "D_指标生"]]


    # _df_3 = _df[~_df["学校名称"].str.contains("（一）")][~_df["学校名称"].str.contains("（二）")]  # 筛出 ACD 类
    filtered_school_names = _df["学校名称"].str.contains("（一）") | _df[
        "学校名称"
    ].str.contains("（二）")
    _df_3 = _df[~filtered_school_names.reindex(_df.index)]
    _df_3 = _df_3.rename(columns={f"招生人数_{year}": "ACD"})
    _df_3 = _df_3.rename(columns={f"指标生人数_{year}": "ACD_指标生"})
    _df_3 = _df_3[["代码", "ACD", "ACD_指标生"]]

    # AC 和 ACD merge on 代码，D merge on 校名
    _df = (
        _df_0.merge(_df_1, on="代码", how="left") 
        .merge(_df_2, on="学校名称", how="left")
        .merge(_df_3, on="代码", how="left") 
    )

    if add_new_tag:
        if year in df.columns:
            # print(f"{year} 已有录取分数列，使用前后录取分数做判断")
            _df = _df.sort_values(by=f"[{year}]", ascending=False)
            _df["学校名称"] += np.where(
                _df[f"[{str(int(year)-1)}]"].isna(), "(new)", ""
            )
        else:
            # print(f"{year} 没有录取分数列，使用招生人数做判断")
            _df = _df.sort_values(by=f"[{scoredyear}]", ascending=False)
            _df["学校名称"] += np.where(
                _df[f"招生人数_{str(int(year)-1)}"].isna(), "(new)", ""
            )

    # _df.to_csv("foobar.csv")
    # 仅返回当年有招生的
    return _df[_df["AC"].notnull() | _df["D"].notnull() | _df["ACD"].notnull()]
 
    

# _df = transpose_ac_and_d("2023", only_gov=False, add_new_tag=False,df_input=df_admit_number_2023).dropna(subset=['AC','D','ACD'], how='all')
# _df = transpose_ac_and_d("2024", only_gov=False, add_new_tag=False,df_input=df_admit_number_2024).dropna(subset=['AC','D','ACD'], how='all')
# print(_df)
# _
# ndf = transpose_ac_and_d("2023")
# print(_ndf[_ndf["学校名称"].str.contains("new")]["学校名称"].to_numpy())
# _ndf = transpose_ac_and_d("2024")
# print(_ndf[_ndf["学校名称"].str.contains("new")]["学校名称"].to_numpy())
```

## 学校排名

**仅排序公办高中。**

排序原则：

1. 第一序：AC 类录取分数
2. 第二序：招生人数，招生人数多着靠前
3. 第三序：代码

```{python}
# 演变图绘制到当前已出成绩的年份（scoredyear）
dfsort = df.copy()

# 从 2025年开始，不想再去抓取招生数据了，只做一下录取数据算了
df_school_info_2025 = pd.read_csv(f"./dataset/2025.csv", decimal=",")[
    ["代码", "学校名称", "办学性质"]
]

# 用 2025 的学校名称刷新 df
dfsort["学校名称"] = (
    dfsort["代码"]
    .map(df_school_info_2025.set_index("代码")["学校名称"])
    .fillna(dfsort["学校名称"])
)
dfsort.update(df_school_info_2025.set_index("代码"))

# 去掉“学校名称”中的“（一）”
dfsort["学校名称"] = dfsort["学校名称"].str.replace("（一）", "")
# 仅保留有录取成绩的row（即：AC类）& 仅保留学校名称和年份排名 column
dfsort = dfsort[dfsort[years_score].notnull().any(axis=1)][years + ["学校名称"]]
# 把所有年份的成绩添加到“名称”列中，后面添加 tooltip 时使用
for y in years:
    dfsort["学校名称"] += "," + df[f"[{y}]"].astype(str)
dfsort.set_index(["学校名称"], inplace=True)
(dfsort)
```

```{python}
# | output: true
# | fig-align: center

l = (
    Line(init_opts=opts.InitOpts(width="100%"))
    .add_xaxis(dfsort.columns.to_list())
    .set_global_opts(
        title_opts=get_title("深圳高中排名演变图"),
        xaxis_opts=opts.AxisOpts(
            type_="category", position="top", boundary_gap=False  # 离散值
        ),
        yaxis_opts=opts.AxisOpts(
            # is_show=False,
            is_inverse=True,
            min_=1,
            max_=len(dfsort.index),
            max_interval=10,
            boundary_gap=False,
        ),
        tooltip_opts=opts.TooltipOpts(
            trigger="item",  # item-鼠标在item上触发，axis-轴上触发
            # {a}：系列名。
            # {b}：数据名。
            # {c}：数据值。
            # {@xxx}：数据中名为 'xxx' 的维度的值，如 {@product} 表示名为 'product'` 的维度的值。
            # {@[n]}：数据中维度 n 的值，如{@[3]}` 表示维度 3 的值，从 0 开始计数。
            formatter=JsCode(
                """function (param) {
                    ret = param.seriesName.split(',')[0] + '<br/>';
                    ret += param.value + ',' + param.seriesName.split(',')[param.dataIndex+1].toString().slice(0,-2)  ;
                    return  ret;
                }"""
            ),
            # slice(0,-2): 去掉 float 小数点后的内容（.0）
        ),
        toolbox_opts=g_toolbox_opts,
        legend_opts=opts.LegendOpts(is_show=False),
    )
)

for name, row in dfsort.iterrows():
    l.add_yaxis(
        series_name=name,
        y_axis=row,
        z_level=1,
        is_symbol_show=True,
        symbol="circle",
        symbol_size=8,
        label_opts=opts.LabelOpts(
            is_show=False,
        ),
    )
    # 添加校名
    row[:-1] = None  # 只保留最后一年的数值，其他列置 non
    l.add_yaxis(
        series_name=name.split(",")[0],
        y_axis=row,
        z_level=0,  # 放在上一个 y 值的底下
        is_symbol_show=True,
        symbol="circle",
        symbol_size=8,
        label_opts=opts.LabelOpts(
            # is_show=False,
            formatter="{a}",  # 用 series_name 作为 label
            position="right"
        ),
    )


grid = Grid(
    init_opts=opts.InitOpts(
        width="100%",
        height="1600px",
        renderer='png', 
        bg_color='white'
    )
)

grid.add(
    l,
    opts.GridOpts(
        pos_top=80,
        pos_right="38.2%",
    ),
    is_control_axis_index=True,
)

grid.render_notebook()
```


本文数据主要来自深圳招生办公室公开文件：

- 2023年考生报考指导手册：[链接1](http://szeb.sz.gov.cn/szzkw/qt/tzgg/content/post_10610222.html)、[链接2](http://szeb.sz.gov.cn/szzkw/zkgg/zkxx/content/post_10610216.html)
- [2024年考生报考指导手册](http://szeb.sz.gov.cn/szszsksbgs/zkcx/zkzz/2024zkwsxczxjd/ksbkzdsc/content/post_11303237.html)

但也有几个关键数据是来自网络，这是导致录取比例、报考等级中的图与实际有偏差的主因：

```{python}
#| echo: false
#| output: asis

print(f"""
- 报名人数: 
    - 2023: 报名约 {enroll_number_2023} 人，AC 类约 {enroll_number_2023_ac} 人({int(ac_rate_2023*100)}%)，D 类约 {enroll_number_2023_d} 人。
    - 2024: 报名约 {enroll_number_2024} 人，AC 类约 {enroll_number_2024_ac} 人({int(ac_rate_2024*100)}%)，D 类约 {enroll_number_2024_d} 人。
- 指标生录取率: 报考等级中再做说明
""")
```

网络参考源：

-  [2024年高中阶段学校招生计划发布](https://mp.weixin.qq.com/s/3oZ_jWBNPYajWd3NFAncTQ)

**以上数据本人未能证实，不承担责任，仅供参考。**

## 学校数量

```{python}
# | echo: false
# | output: asis

# DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)

#     axis: 决定是删除行(0)还是删除列(1)。
#     how: 决定删除包含任意缺失值的行/列('any')还是只删除包含全部缺失值的行/列('all')。
#     thresh: 设置行/列中至少需要有多少个非缺失值才能被保留。
#     subset: 指定需要检查缺失值的特定列。
#     inplace: 如果设为 True,则直接修改原有的 DataFrame,否则返回一个新的 DataFrame。

_df23 = transpose_ac_and_d(
    "2023", only_gov=False, add_new_tag=False, df_input=df_admit_number_2023
).dropna(subset=["AC", "D", "ACD"], how="all")
_df24 = transpose_ac_and_d(
    "2024", only_gov=False, add_new_tag=False, df_input=df_admit_number_2024
).dropna(subset=["AC", "D", "ACD"], how="all")
_df23t = _df23["办学性质"].value_counts()
_df24t = _df24["办学性质"].value_counts()

print(
    f"""
|普高数量|公办|民办|
|--|--|--|
|2023|{_df23t['公办']}|{_df23t['民办']}|
|2024|{_df24t['公办']}({_df24t['公办']-_df23t['公办']:+d})|{_df24t['民办']}({_df24t['民办']-_df23t['民办']})|
"""
)
```

## 学位数量

```{python}
def admit_number_bar(year: str):
    """招生人数柱状图"""
    _df = transpose_ac_and_d(year)
    _df[f"Total"] = _df["AC"] + _df["D"] + _df["ACD"]
    _df = _df[["学校名称", "AC", "D", "ACD", "Total"]]

    bar = (
        Bar(init_opts=opts.InitOpts())
        # add_dataset() 中给出数据后，add_yaxis 会自动依次选择第 2、3...列
        # pyecharts 绘图是逆序的, df.iloc[::-1] 可以实现逆序
        .add_dataset(
            source=[_df.columns.values.tolist()] + _df.iloc[::-1].values.tolist()
        )
        .add_yaxis(
            series_name=f"AC",
            y_axis=[],  # 自动选择第 2 列
            label_opts=opts.LabelOpts(position="insideRight"),
            stack="stack1",
        )
        .add_yaxis(
            series_name=f"D",
            y_axis=[],  # 自动选择第 3 列
            label_opts=opts.LabelOpts(position="insideLeft"),
            stack="stack1",
        )
        .add_yaxis(
            series_name=f"ACD",
            y_axis=[],  # 自动选择第 4 列
            label_opts=opts.LabelOpts(position="insideLeft"),
            stack="stack1",
        )
        .set_global_opts(
            title_opts=get_title(f"深圳 {year} 公办普高招生人数"),
            legend_opts=opts.LegendOpts(is_show=True, pos_bottom=10),
            xaxis_opts=opts.AxisOpts(name=""),
            yaxis_opts=opts.AxisOpts(type_="category"),
            toolbox_opts=g_toolbox_opts,
            # visualmap_opts=opts.VisualMapOpts(
            #     orient="horizontal",
            #     pos_left="center",
            #     min_=80,
            #     max_=1700,
            #     dimension=1,
            #     range_color=["#D7DA8B", "#E15457"],
            # ),
        )
    )

    grid = Grid(
        init_opts=opts.InitOpts(
            width="100%", height="1600px", renderer="svg", bg_color="white"
        )
    )

    grid.add(
        bar,
        opts.GridOpts(
            pos_left="50%",
            # pos_right='20px',
        ),
        is_control_axis_index=True,
    )
    return grid
```

> 仅列举了公办普高。
> 以已发布的最新年份的 AC 类录取分数线排序，所以当年新学校在当年录取分公布前会排在末尾，分数公布后会得到修正。

### 2023

```{python}
# | output: true
admit_number_bar("2023").render_notebook()
```

### 2024

```{python}
# | output: true
admit_number_bar("2024").render_notebook()
```

## 录取比例

```{python}
def enroll_rate_table(year: str, eroll_ac: int, eroll_d: int):
    """绘制录取人数和比例的表格，ACD 类学校按 3:1 拆分到 AC:D"""
    table = Table()

    headers = [
        "类别",
        "报名人数",
        "学位数量/录取率",
        "指标生/录取率",
        "正录/录取率",
    ]

    # 报名：enroll/erl
    # 录取：admit/adm
    erl_total = eroll_ac + eroll_d
    _df = transpose_ac_and_d(year)
    # 将 ACD 的名额按 3:1 拆分给 AC:D
    adm_acd = _df[f"ACD"].sum()
    adm_ac = _df[f"AC"].sum() + adm_acd * 0.75
    adm_d = _df[f"D"].sum() + adm_acd * 0.25
    adm_acd_zbs = _df[f"ACD_指标生"].sum()
    adm_ac_zbs = _df[f"AC_指标生"].sum() + adm_acd_zbs * 0.75
    adm_d_zbs = _df[f"D_指标生"].sum() + adm_acd_zbs * 0.25

    rows = [
        [
            "AC+D",
            erl_total,
            f"{adm_ac + adm_d:.0f}/{100*(adm_ac + adm_d)/erl_total:.0f}%",
            f"{adm_ac_zbs + adm_d_zbs:.0f}/{100*(adm_ac_zbs + adm_d_zbs)/erl_total:.0f}%",
            f"{adm_ac - adm_ac_zbs + adm_d - adm_d_zbs:.0f}/{100*(adm_ac - adm_ac_zbs + adm_d - adm_d_zbs)/erl_total:.0f}%",
        ],
        [
            "AC",
            eroll_ac,
            f"{adm_ac:.0f}/{100*adm_ac/eroll_ac:.0f}%",
            f"{adm_ac_zbs:.0f}/{100*adm_ac_zbs/eroll_ac:.0f}%",
            f"{adm_ac - adm_ac_zbs:.0f}/{100*(adm_ac - adm_ac_zbs)/eroll_ac:.0f}%",
        ],
        [
            "D",
            eroll_d,
            f"{adm_d:.0f}/{100*adm_d/eroll_d:.0f}%",
            f"{adm_d_zbs:.0f}/{100*adm_d_zbs/eroll_d:.0f}%",
            f"{adm_d - adm_d_zbs:.0f}/{100*(adm_d - adm_d_zbs)/eroll_d:.0f}%",
        ],
    ]
    table.add(headers, rows)
    return table
```

**特别说明：**

- 将 ACD 类学校按 3:1 拆分到 AC:D 中，不单独做 ACD 一行。
- 指标生和正录都是招生名额，但实际每年指标生都用不满，甚至有些新学校、尾部学校的指标生大比例废弃，所以下表中的总比例是正确的，但指标生比例比实际高，正录比例比实际低。

### 2023 

```{python}
# | output: true
enroll_rate_table("2023", enroll_number_2023_ac, enroll_number_2023_d).render_notebook()
```

上表显示：AC 类录取比例 85%，如果指标生都用满的话，42% 会通过指标生上学，但其实可能这 42% 只有一半被使用，其他会退回到正录。

### 2024

```{python}
# | output: true
enroll_rate_table("2024", enroll_number_2024_ac, enroll_number_2024_d).render_notebook()
```

总体录取比例与 2023 年几乎持平，AC 类学位上升但报名人数增多，录取比例略有下降。

## 报考等级

我们试图要回答的两个问题：

1. 孩子当前的等级（如：B+）该怎么报**指标生志愿** ？
2. 孩子当前的等级（如：B+）该怎么报**正录志愿**？

第 1 个问题因为指标生运作机制，且涉及因素较多，包括运气，致使指标生通常比正录的分数要低，正录的分数线通常在最终高一开学后可能是中位线，而不是最低线（新学校除外，可能有特例）—— 所以此处不讨论该问题，填报时根据下面的正录参考，适当提高 5~15 分填报即可。

第 2 个问题用后面的图展示，主要通过描述**学生数量**与**学位数量**的匹配关系来展开。

- 内圈 A+、A、B+、B……是学生数量及其等级  
- 外圈是各个学校按当前或前一年教育局公布的录取分数排名后，学位数量的累积  
- 外圈的缺口：即学生数量 - 学位数量的差值 —— 民办或职校去向  
- 推荐在电脑上打开，手机上查看比较拥挤。

其中有一个重要的问题：如何合理的去掉指标生对正录志愿报名的影响，我设计了这样的**指标生录用比例数学模型**：

1. 根据排序，前 30 所学校的指标生有效使用率为 1 —— 即：前 30 大的指标生不会浪费的。
2. 从 31 开始逐步降低，至当年度的前 80% 院校降为 0 —— 如：2023 年 89 所公办学校，31.北莫 - 72.行知 的指标生录取率从 1 至 0 等阶下降，41 所学校，下降阶梯为 0.025
3. 80% 之后，指标生录取率取 0 —— 即指标生忽略不计。
4. 此模型对当年的新学校，或争议比较大的学校，或网红学校……都会不准确，但这是少数个别情况，先忽略不计吧。

**此模型未必正确，所以下图仅供参考。**

```{python}
# | echo: false
# | output: asis

# def admit_number_sum(year: str, category: str = 'ac'):
#     """ dfsum: 添加一列存放累积数据 """
#     dfsum = df.sort_values(by=f"[{year}]", ascending=False)
#     dfsum["学校名称"] += np.where(dfsum[f"[{str(int(year)-1)}]"].isna(), "(new)","") # 识别是否为新校
#     dfsum = dfsum[["学校名称", f"招生人数_{year}_{category}", f"{category}_指标生"]]
#     # 累积值为正录的人数（即：减去指标生和自招生）
#     dfsum[f"累计_{category}"] = (dfsum[f"招生人数_{year}_{category}"] - dfsum[f"{category}_指标生"]).cumsum(axis=0)
#     return dfsum


def level_sunburst(year: str, ac_or_d: str, enroll_total: int):
    """按比例(zbs_rate)去掉指标生后的等级旭日图

    enroll_total: enroll total, 总报名人数，不是录取（admit）人数
    """
    data_grade = [
        {"name": "A+", "value": enroll_total * 0.05},
        {"name": "A", "value": enroll_total * 0.2},
        {"name": "B+", "value": enroll_total * 0.25},
        {"name": "B", "value": enroll_total * 0.25},
        {"name": "C+", "value": enroll_total * 0.2},
        {"name": "C", "value": enroll_total * 0.05},
    ]

    ac_or_d = ac_or_d.upper()
    _df = transpose_ac_and_d(year)

    data = []  # sunburst 的 datasource 是数组，要做数据格式转换
    idx = 0
    adm_sum = 0  # 全部学位累积值
    adm_sum_zbs = 0  # 指标生学位累计值
    adm_sum_zbs_real = 0  # 指标生实录累计值
    for name, row in _df.iterrows():
        _all = row[f"{ac_or_d}"] if not pd.isnull(row[f"{ac_or_d}"]) else 0
        # 把 ACD 的名额按 3:1 拆分给 AC:D
        _all += (
            0
            if pd.isnull(row["ACD"])
            else (row["ACD"] * (0.75 if ac_or_d == "AC" else 0.25))
        )

        _zbs = (
            row[f"{ac_or_d}_指标生"] if not pd.isnull(row[f"{ac_or_d}_指标生"]) else 0
        )
        # 其实是没有必要的，因为 ACD 类学校基本没有指标生
        _zbs += (
            0
            if pd.isnull(row["ACD_指标生"])
            else (row["ACD_指标生"] * (0.75 if ac_or_d == "AC" else 0.25))
        )
        adm_sum += _all
        adm_sum_zbs += _zbs

        if year in row.index.names:
            _idx = row[f"{year}"]
        else:
            _idx = row[f"{int(year)-1}"]

        # 指标生录取率模型
        top = 30
        zbs_rate = (
            1
            if _idx >= 1 and _idx <= top
            else (
                1 - (_idx - top) / (_df23t["公办"] * 0.8 - top)
                if _idx <= _df23t["公办"] * 0.8
                else 0
            )
        )
        _zbs *= zbs_rate  # 用录用比例修订指标生
        adm_sum_zbs_real += _zbs

        idx += 1
        data.append(
            {"name": str(idx) + "_" + row["学校名称"], "value": int(_all - _zbs)}
        )

    print(
        f"""
    - {ac_or_d} 类学位数量 {int(adm_sum)}，指标生学位 {int(adm_sum_zbs)}，正录学位 {int(adm_sum - adm_sum_zbs)}；
    - 指标生录用率模型修订后：指标生实录 {int(adm_sum_zbs_real)}人, 正录实录 {int(adm_sum - adm_sum_zbs_real)}人，
    - {ac_or_d} 类总报名 {enroll_total}，缺口{int(enroll_total - adm_sum)}
    """
    )

    # 计算缺口时也要减去指标生
    data.append(
        {
            "name": "缺口",
            "value": int(enroll_total - adm_sum),
        }
    )

    return (
        Sunburst(
            init_opts=opts.InitOpts(
                width="100%",
                height="600px",
                is_horizontal_center=True,
                renderer="png",
                bg_color="white",
            )
        )
        .add(
            "",
            data_pair=data_grade,
            highlight_policy="ancestor",
            radius=[0, "95%"],
            sort_=types.JsCode("null"),
            levels=[
                {},
                {"r0": "15%", "r": "23%", "label": {"align": "right"}},
            ],
            label_opts=opts.LabelOpts(font_size=10, font_weight="bold"),
        )
        .add(
            "",
            data_pair=data,
            highlight_policy="ancestor",
            radius=[0, "95%"],
            sort_=types.JsCode("null"),
            levels=[
                {},
                {"r0": "25%", "r": "100%", "label": {"align": "right"}},
            ],
            label_opts=opts.LabelOpts(
                # formatter + rich = 可实现更丰富的自定义显示
                formatter="{schoolname| {b}}",
                rich={"schoolname": {"fontSize": "9px"}},
            ),
        )
        .set_global_opts(
            title_opts=get_title(f"{year} {ac_or_d} 类正录等级图"),
            toolbox_opts=g_toolbox_opts,
            legend_opts=opts.LegendOpts(is_show=False),
        )
    )
```

### 2023

#### AC 类

```{python}
# | output: asis
level_sunburst("2023", "AC", enroll_number_2023_ac).render_notebook()
```

鼠标放在上图中的某个学校，会提示学校名称和 AC 类的学位数量，举例说一下这个学位是如何去除指标生计算而来的：

- 比如 `1.深中`，手册中 AC 招生 `1625` 人，指标生 `813` 人，利用率1，即正录 `1625 - 813 = 812` —— 与图中一致。
- 比如 `54.弘知`，手册中 AC 招生 `710` 人，指标生 `355` 人，指标生录用率 `1 - (54-31)/(89*0.8-31) = 0.4417`，即 `355*0.417 = 148` 人走指标生，剩下 `710 - 148 = 561` 正录 —— 与图中一致。
- 比如 `60.光高`，手册中 AC 招生 `1020` 人，指标生 `510` 人，指标生录用率 `1 - (60-31)/(89*0.8-31) = 0.271`，即 `510*0.271 = 139` 人走指标生，剩下 `1020 - 139 = 881` 正录 —— 与图中一致。

现在来尝试解答上面的第 2 个问题：

**如果孩子摸底成绩在 B+ 中部，如何填报 12 个普高志愿：**

- 冲（2个）：可以从 B+ 顶部（34.宝一外/545 ~ 40.福田/538）选择；
- 稳（6个）：可以从 B+ 中底部（41.龙津/537 ~ 60.光高/505）中选择，间距 32 分，阶梯3~5分；
- 保（4个）：可以在 B 区选择，保底建议安全第一，听取班主任建议；


**填报志愿时，分数的绝对值并不重要，2023 年题目简单，大家分数都高，但等级是基本不变的，孩子只要正常发挥，A 的依然是 A, B 的还会是 B，所以报志愿要按等级来报，一定要找老师了解孩子摸底考试在学校的排名和等级，结合上表填报志愿。**

**另外对自家孩子等级的评估要准确，本校的 B+ 未必是全市的 B+，有可能是 A，也有可能是 B。—— 要用全市的等级**

> 复盘：  
> 2023 年 7 月公布中考等级线   
> A+/573：只有top2学校了；  
> A/542：在 39.罗外附近;   
> B+/489: 在 75.深外理工附近；  
> A+ 一致，A 有小偏差，B+ 和图中并不一致，这是因为教育局发布的等级线是包括指标生的，即全体学生，上图是去掉指标生的，前面也讲过教育局发布的等级线开学后会发现是中档分数，并不是最低分数。


#### D 类

```{python}
# | output: asis
level_sunburst("2023", "D", enroll_number_2023_d).render_notebook()
```

D 类看着太扎心了！只有 A 分数段的中部以上，才有公办普高读，大部分都要去民办或职高了。

**特别声明：**

学校排名不是固定的，每年都会有学校异军突起或大幅陷落，和学校的宣传、校舍改造、迁址、师资队伍变化、出口成绩……等诸多因素相关，2023 年的上图只能作为 2023 年而复盘回顾，和 2024 年早期预估。待 2024 年 5 月学校招生人数公布后，叠加 2023 年的排名和新学校的位置预估，做出新图，才更合适做 2024 年的志愿填报参考。


### 2024


#### AC 类

```{python}
# | output: asis
level_sunburst("2024", "AC", enroll_number_2024_ac).render_notebook()
```

#### D 类

```{python}
# | output: asis
level_sunburst("2024", "D", enroll_number_2024_d).render_notebook()
```

<br/>

**最后！祝愿深圳初中生都能够正常发挥、不留遗憾。**

耸立在眼前的，是一道很高很高的墙壁，墙的对面，有着怎样的风景呢，看上去会是什么样子呢？顶端的景色，凭我一己之力，定然无法窥见的景色，然而若我并非孤身一人。。。。
————日向翔阳

**无论普高、职高、中专、技校，未来被人工智能浪潮重塑的千行百业下，一切皆有可能，加油吧！少年！**